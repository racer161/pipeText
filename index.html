<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <script src="tree-sitter/tree-sitter.js"></script>
    <link rel="stylesheet" href="styles/selenized-dark.css">
    <link rel="stylesheet" href="styles/base.css">
  </head>
  <body>
        <script>
            async function get_lang(url)
            {
                
                let lang = await TreeSitter.Language.load(url);
                return lang;
            }
        </script>
<div spellcheck="false", contenteditable="true" id="text-container" style="white-space: pre;">import Big from "big.js";

import operate from "./operate";
import isNumber from "./isNumber";

/**
    * Given a button name and a calculator data object, return an updated
    * calculator data object.
    *
    * Calculator data object contains:
    *   total:String      the running total
    *   next:String       the next number to be operated on with the total
    *   operation:String  +, -, etc.
    */
export default function calculate(obj, buttonName) {
    if (buttonName === "AC") {
    return {
        total: null,
        next: null,
        operation: null,
    };
    }

    if (isNumber(buttonName)) {
    if (buttonName === "0" && obj.next === "0") {
        return {};
    }
    // If there is an operation, update next
    if (obj.operation) {
        if (obj.next) {
        return { next: obj.next + buttonName };
        }
        return { next: buttonName };
    }
    // If there is no operation, update next and clear the value
    if (obj.next) {
        const next = obj.next === "0" ? buttonName : obj.next + buttonName;
        return {
        next,
        total: null,
        };
    }
    return {
        next: buttonName,
        total: null,
    };
    }

    if (buttonName === "%") {
    if (obj.operation && obj.next) {
        const result = operate(obj.total, obj.next, obj.operation);
        return {
        total: Big(result)
            .div(Big("100"))
            .toString(),
        next: null,
        operation: null,
        };
    }
    if (obj.next) {
        return {
        next: Big(obj.next)
            .div(Big("100"))
            .toString(),
        };
    }
    return {};
    }

    if (buttonName === ".") {
    if (obj.next) {
        // ignore a . if the next number already has one
        if (obj.next.includes(".")) {
        return {};
        }
        return { next: obj.next + "." };
    }
    return { next: "0." };
    }

    if (buttonName === "=") {
    if (obj.next && obj.operation) {
        return {
        total: operate(obj.total, obj.next, obj.operation),
        next: null,
        operation: null,
        };
    } else {
        // '=' with no operation, nothing to do
        return {};
    }
    }

    if (buttonName === "+/-") {
    if (obj.next) {
        return { next: (-1 * parseFloat(obj.next)).toString() };
    }
    if (obj.total) {
        return { total: (-1 * parseFloat(obj.total)).toString() };
    }
    return {};
    }

    // Button must be an operation

    // When the user presses an operation button without having entered
    // a number first, do nothing.
    // if (!obj.next && !obj.total) {
    //   return {};
    // }

    // User pressed an operation button and there is an existing operation
    if (obj.operation) {
    return {
        total: operate(obj.total, obj.next, obj.operation),
        next: null,
        operation: buttonName,
    };
    }

    // no operation yet, but the user typed one

    // The user hasn't typed a number yet, just save the operation
    if (!obj.next) {
    return { operation: buttonName };
    }

    // save the operation and shift 'next' into 'total'
    return {
    total: obj.next,
    next: null,
    operation: buttonName,
    };
}
</div>

    <script type="module">
        import init, { Pipetext } from '/pkg/pipetext.js';

        async function run() 
        {

            await TreeSitter.init();
             
            await init();
            
            let code_div = document.getElementById("text-container");

            
            let pipetext = await Pipetext.from_div(code_div);
            
            var t0 = performance.now();
            pipetext.update_html();
            console.log("Initialized in " + (performance.now() - t0) + " milliseconds.");

            code_div.addEventListener("keydown", (e) => 
            {
                event.preventDefault(); 
                event.stopPropagation();
                console.log(e);
                var t0 = performance.now(); 
                pipetext.key_down_handler(e);
                console.log("Total " + (performance.now() - t0) + " milliseconds.");
            });

            // addEventListener version
            document.addEventListener('selectionchange', () => 
            {
                pipetext.selection_change_handler();
                //let selection = document.getSelection();
                //console.log(selection.getRangeAt(0));
            });

            //pipetext.edit(5,12,"");

            //console.log(pipetext.get_str());
        }

        function get_caret_character_offset(element) 
        {
            var caretOffset = 0;
            var doc = element.ownerDocument || element.document;
            var win = doc.defaultView || doc.parentWindow;
            var sel;
            if (typeof win.getSelection != "undefined") {
                
                sel = win.getSelection();
                if (sel.rangeCount > 0) {
                    //console.log("big gainz!");
                    var range = win.getSelection().getRangeAt(0);
                    var preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(element);
                    preCaretRange.setEnd(range.startContainer, range.startOffset);
                    return preCaretRange.toString().length;
                }
            } else if ( (sel = doc.selection) && sel.type != "Control") {
                var textRange = sel.createRange();
                var preCaretTextRange = doc.body.createTextRange();
                preCaretTextRange.moveToElementText(element);
                preCaretTextRange.setEndPoint("EndToEnd", textRange);
                caretOffset = preCaretTextRange.text.length;
            }
            return caretOffset;
        }

        run();
    </script>
  </body>
</html>